
#=======================================================
#' Simulated genotypes
#'
#' Simulate SNP genotype data from a pedigree, with optional missingess and
#'  errors.
#'
#' Please ensure the pedigree is a valid pedigree, for example by first running
#' fixPedigree() from library Pedantics.
#'
#' @param PedFile  Name of the pedigree file, with columns ID - dam - sire
#' @param MafFile  (optional) file with minor allele frequency at each locus.
#'   If none specified, allele frequencies will be sampled from a uniform
#'   distribution between 0.3 and 0.5
#' @param OutFile  filename for simulated genotypes
#' @param nSnp  number of SNPs to simulate
#' @param nGen  maximum number of generations to consider
#' @param PropLQ  proportion of low-quality samples
#' @param MisHQ  average missingness for high-quality samples, assuming a
#'    beta-disstribution with alpha = 1.
#' @param MisLQ  average missingness in low-quality samples
#' @param ParMis  Proportion of parents with fully missing genotype
#' @param ErHQ  error rate in high quality samples. Default value is
#'   0.005, following Anderson & Garcia 2006.
#' @param ErLQ  error rate in low quality samples
#' @param quiet suppress messages
#'
#' @return a file with genotype data encoded as 0/1/2/-9, in a format
#'   similar to that generated by Plink's --recodeA option.
#'
#' @author Jisca Huisman, \email{jisca.huisman@gmail.com}
#'
#' @export

SimGeno <- function(PedFile = "TruePed.txt",
                    MafFile = NA,
					          OutFile = "SimGeno.txt",
                    nSnp = 400,
                    nGen = 10,
                    PropLQ = 0,
                    MisHQ = 0.005,
                    MisLQ = 0.30,
                    ParMis = 0.2,
                    ErHQ = 5e-3,
                    ErLQ = 5e-3,
					          quiet = FALSE)
{
  if (interactive() & !quiet) {
    ANS <- readline(prompt = paste("Results will be written to", OutFile, "in", getwd(),
                                   "\n Note that this may overwrite existing files. \n",
                                   "Press <N> to abort, or any other key to continue."))
    if (substr(ANS, 1, 1) %in% c("N", "n")) stop()
  }

  Ped <- ReadTable(PedFile)

  if (!is.na(MafFile)) {
    Q <- as.numeric(t(ReadTable(MafFile)))
    nSnp <- length(Q)
  } else {
    Q <- round(stats::runif(nSnp, min=0.3, max=0.5),3)
  }

  #================================
  # check & prep

#  Ped <- fixPedigree(Ped)  # requires library(pedantics)
  for (x in 1:3) {
    Ped[,x] <- as.character(Ped[,x])
  }
  Founders <- which(is.na(Ped[,2]) & is.na(Ped[,3]))
  NotParent <- which(!Ped[,1] %in% Ped[,2] & !Ped[,1] %in% Ped[,3])
  if (length(intersect(Founders, NotParent))>0) {
    Ped <- Ped[-intersect(Founders, NotParent),]
  }
  nInd <- nrow(Ped)

  Q[Q>0.5] <- 1-Q[Q>0.5]


  #================================
  # divide pedigree into `generations'
  # the parents of an individual must come from earlier cohorts than itself,
  # or from the founder population

  Ped$Ci <- NA  # individual's cohort
  Ped$Cd <- NA  # dam's cohort
  Ped$Cs <- NA  # sire's cohort
  Ped$Ci[is.na(Ped[,2]) & is.na(Ped[,3])] <- 0
  for (x in 0:nGen) {
    Ped$Cd[is.na(Ped$Cd) & Ped[,2] %in% Ped[which(Ped$Ci<=x), 1]] <- x
    Ped$Cs[is.na(Ped$Cs) & Ped[,3] %in% Ped[which(Ped$Ci<=x), 1]] <- x
    Ped$Ci[which(is.na(Ped$Ci) &
                   (Ped$Cd<=x | is.na(Ped[,2])) &
                   (Ped$Cs<=x | is.na(Ped[,3])))] <- x+1
  }

  Ped$nd <- sapply(Ped[,2], function(x) ifelse(is.na(x), NA, which(Ped[,1]==x)))
  Ped$ns <- sapply(Ped[,3], function(x) ifelse(is.na(x), NA, which(Ped[,1]==x)))

  #================================
  # simulate genotypes
  # founders: random draw of alleles under HWE
  # non-founders: following Mendelian inheritance

  SGeno <- matrix(NA, nSnp, nInd)

  for (i in which(Ped$Ci==0)) {
    SGeno[, i] <- stats::rbinom(nSnp, 2, prob=Q)
  }

  for (x in 1:nGen) {
    for (i in which(Ped$Ci==x)) {
      if (!is.na(Ped$nd[i]) & !is.na(Ped$ns[i])) {
        SGeno[, i] <- rowSums(cbind(stats::rbinom(nSnp, 1, prob=SGeno[,Ped$nd[i]]/2),
                                    stats::rbinom(nSnp, 1, prob=SGeno[,Ped$ns[i]]/2)))
      } else if (!is.na(Ped$nd[i])) {
        SGeno[, i] <- rowSums(cbind(stats::rbinom(nSnp, 1, prob=SGeno[,Ped$nd[i]]/2),
                                    stats::rbinom(nSnp, 1, prob=Q)))
      } else if (!is.na(Ped$ns[i])) {
        SGeno[, i] <- rowSums(cbind(stats::rbinom(nSnp, 1, prob=Q),
                                    stats::rbinom(nSnp, 1, prob=SGeno[,Ped$ns[i]]/2)))
      }
    }
  }

  #================================
  # genotyping errors & missing values:
  # simulate mixture of high-quality and low-quality samples

  iLQ <- sample.int(nInd, round(nInd*PropLQ), replace=FALSE)
  iHQ <- setdiff(1:nInd, iLQ)
  if (MisLQ>0 & PropLQ>0) {
    nmis.LQ <- round(stats::rbeta(length(iLQ), 1, 1/MisLQ-1) * nSnp)
    for (i in 1:length(iLQ)) {
      SGeno[sample.int(nSnp, nmis.LQ[i]), iLQ[i]] <- -9
    }
  }
  nmis.HQ <- round(stats::rbeta(nInd-length(iLQ), 1, 1/MisHQ-1) * nSnp)


  for (i in 1:length(iHQ)) {
    SGeno[sample.int(nSnp, nmis.HQ[i]), iHQ[i]] <- -9
  }

	if (MisHQ>0) {
	  nEr.HQ <- round(stats::runif(nInd-length(iLQ), 1, 1/MisHQ-1) * nSnp)
	} else {
	  nEr.HQ <- 0
	}
  ErXH <- which(stats::rbinom(length(iHQ)*nSnp, 1, prob=ErHQ)==1)
  SGeno[, iHQ][ErXH] <- sample(0:2, length(ErXH), replace=TRUE)

  if (MisLQ<1 & MisLQ>0) {
    nEr.LQ <- round(stats::runif(length(iLQ), 1, 1/MisLQ-1) * nSnp)
    ErXL <- which(stats::rbinom(length(iLQ)*nSnp, 1, prob=ErLQ)==1)
    SGeno[, iLQ][ErXL] <- sample(0:2, length(ErXL), replace=TRUE)
  }
  #================================
  if (ParMis>0) {
    IsParent <- which(Ped[,1] %in% c(Ped[,2], Ped[,3]))
    NotSampled <- sample(IsParent, round(length(IsParent)*ParMis), replace=FALSE)
    SGeno <- SGeno[, -NotSampled]
    colnames(SGeno) <- Ped[-NotSampled, 1]
  } else {
    colnames(SGeno) <- Ped[, 1]
  }

  #================================
  # output

  utils::write.table(t(SGeno), OutFile, quote=FALSE, col.names=FALSE)
  rm(SGeno, Ped)
}


#============================================================================
#============================================================================
# Utils functions for comparisons


#' Compare two vectors
#'
#' Compare a vector with inferred sibs to a vector of `true' sibs
#'
#' @param  Infrd  vector of inferred sibs
#' @param  Simld  vector of true sibs
#' @param  SNPd character vector with IDs of genotyped individuals
#'
#' @return a named numeric vector of length 4, with the total length of Simld,
#'   the length of the intersect of the two vectors, the number occurring in
#'   Infrd but not Simld ('err'), and the number occuring in Simld but not
#'   Infrd ('missed').

Vcomp <- function(Infrd, Simld, SNPd)
{
  total <- length(Simld)
  both <- length(intersect(Infrd, Simld))
  err <- length(setdiff(Infrd[Infrd %in% SNPd], Simld))
  missed <- length(setdiff(Simld, Infrd))
  c(total=total, both=both, err=err, missed=missed)
}


#======================================================================
#' Find the closest matching inferred sibship to a true sibship
#'
#' @param SimX  a vector with the IDs in the true sibship
#' @param Infrd  a list of vectors with the IDs in the inferred sibships
#' @param SNPd character vector with IDs of genotyped individuals
#'
#' @return a named numeric vector with the number of matches ('NumMatch'),
#'   the position of the best match ('Best'), the inferred sibship size of
#'   this best match ('Tot'), the number of matching IDs ('OK'), and the
#'   number of mismatches ('err').

SibMatch <- function(SimX, Infrd, SNPd)
{
  VC <- sapply(Infrd, Vcomp, SimX, SNPd)
  mtch <- which(VC[2,]>0)
  if (length(mtch)>1) {
    mtch <- which.max(VC[2,])[1]  # which inferred sibship has most members of true sibship
  }
  if (length(mtch)==1) {
    if (VC["err", mtch] > VC["both", mtch]) {
      mtch <- NULL
    }
  }
  if (length(mtch)==1) {
    OUT <- data.frame(NumMatch = sum(VC[2,]>0),
             Best = colnames(VC)[mtch],  # as.numeric(substr(colnames(VC)[mtch],3,5)),
             Tot = VC["total", mtch],
             OK = VC["both", mtch],
             Er = VC["err", mtch], stringsAsFactors=FALSE)
  } else {
    OUT <- data.frame(NumMatch=0, Best=NA,  Tot= length(SimX), OK = NA, Er = NA)
  }
  OUT
}


#======================================================================
# transpose matrix to data.frame  (sapply returns wrong format)

# adapted from Hmisc::all.is.numeric
all.is.numeric <- function (x, what = c("test", "vector"))
{
  what <- match.arg(what)
  isnum <- suppressWarnings(!any(is.na(as.numeric(stats::na.exclude(x)))))
  if (what == "test")
    isnum
  else if (isnum)
    as.numeric(x)
  else x
}

tdf <- function(M)
{
  DF <- matrix(NA, ncol(M), nrow(M))
  for (r in 1:nrow(M)) {
    DF[, r] <- unlist(M[r, ])
  }
  DF <- as.data.frame(DF, stringsAsFactors = FALSE, row.names=colnames(M))
  for (r in 1:ncol(DF)) {
    if (all.is.numeric(DF[, r]))  DF[, r] <- as.numeric(DF[, r])
  }
  names(DF) <- rownames(M)
  DF
}

#============================================================================
#============================================================================
#' Compare two Pedigrees
#'
#' Compare an inferred pedigree to a previous or simulated pedigree,
#' including comparison of sibship clusters and sibship grandparents.
#'
#' Provide either a dataframe of the pedigree, or the filename of a text file.
#' In both cases, the inferred pedigree 2 is assumed to have the columns id-
#' dam-sire, and Pedigree 1 may be in the same order (FlipCols=FALSE, default)
#' or have order id-sire-dam, in which case FlipCols=TRUE should be used.
#'
#' @param  Ped1 Original pedigree, dataframe with 3 columns.
#' @param  PedFile1  filename of original pedigree, only the first 3 columns
#'   will be used. Provide EITHER Ped1 OR PedFile1.
#' @param  Ped2 Infered pedigree, e.g. SeqOUT$PedSeq
#' @param  PedFile2  filename of infered pedigree, default `PedSeq.txt'
#' @param  sep1  the field separator character in 'PedFile1'
#' @param  sep2  the field separator character in 'PedFile2'
#' @param  DumPrefix  The dummy prefix used. If NULL, the intersect between
#'   the IDs in Pedigrees 1 and 2 is taken as the list of genotyped
#'   individuals. Otherwise, all individuals in Pedigree 2 with IDs
#'   not starting with the Dummy prefix are taken.
#' @param  FlipCols  Are dam & sire columns in the same order (FlipCols=FALSE)
#' or in flipped order (FlipCols=TRUE) in the two pedigree files?
#' @param MergedPed  Return combined pedigree? This including three columns
#'  (id.real, dam.real, sire.real) where dummy IDs in Pedigree 2 are replaced
#'  by the most likely non-genotyped individual ID from Pedigree 1.
#'
#' @return when MergedPed=FALSE (default) a 7 x 5 x 2 named numeric array, and when
#'   MergedPed=TRUE a list with this array and the combined pedigree.
#'
#' The first dimension of the array denotes the following categories:
#' \describe{
#'   \item{RR}{Real genotyped individual, real genotyped parent}
#'   \item{RD}{Real individual, dummy parent (at least 1 genotyped sibling}
#'   \item{RT}{Real individual, total}
#'   \item{DR}{Dummy individual (at least 2 genotyped offspring, real parent
#'      (i.e., grandparent of the sibship}
#'   \item{DD}{Dummy individual, dummy parent}
#'   \item{DT}{Dummy total}
#'   \item{TT}{Total total, includes all genotyped & non-genotyped individuals
#'      in the pedigree}
#' }
#' The second dimension gives the outcomes:
#' \describe{
#'   \item{Total}{The total number of individuals with a parent assigned in
#'     either or both pedigrees}
#'   \item{Match}{The same parent is assigned in both pedigrees (non-missing).
#'      For dummy parents, it is considered a match if the inferred sibship
#'      containing the most offspring of a non-genotyped parent, consists for
#'      more than half of its offspring.}
#'   \item{Mismatch}{Different parents assigned in the two pedigrees. When
#'    a sibship according to Pedigree 1 is split over two sibships in Pedigree
#'    2, the smaller fraction is included in the count here.}
#'   \item{P1only}{Parent in Pedigree 1 but not 2; includes non-assignable
#'     parents.}
#'   \item{P2only}{Parent in Pedigree 2 but not 1.}
#' }
#' The third dimension separates between maternal and paternal assignments,
#' where e.g. paternal 'DR' is the assignment of fathers to both maternal and
#' paternal sibships.
#'
#' @author Jisca Huisman, \email{jisca.huisman@gmail.com}
#'
#' @seealso \code{\link{sequoia}}
#'
#' @export

PedCompare <- function(Ped1 = NULL,
                       PedFile1 = NULL,
                       Ped2 = NULL,
                       PedFile2 = "PedSeq.txt",
                       sep1 = "\t",
                       sep2 = "",
                       DumPrefix = c("F0", "M0"),
                       FlipCols = FALSE,
                       MergedPed = FALSE)
{
  if(sum(is.null(Ped1), is.null(PedFile1))!=1) stop("Provide either Ped1 OR PedFile1")
  if(is.null(Ped2) & is.null(PedFile2)) stop("Provide either Ped2 OR PedFile2")
  if(is.null(Ped1)) Ped1 <- ReadTable(PedFile1, sep=sep1)[,1:3]
  if(is.null(Ped2)) Ped2 <- ReadTable(PedFile2, sep=sep2)[,1:3]
  if (FlipCols) Ped1 <- Ped1[, c(1,3,2)]
  names(Ped1) <- c("id", "dam.1", "sire.1")
  names(Ped2)[1:3] <- c("id", "dam.2", "sire.2")
  for (i in 1:3) Ped1[, i] <- as.character(Ped1[, i])
  for (i in 1:3) Ped2[, i] <- as.character(Ped2[, i])
  if (!any(Ped2$id %in% Ped1$id))  stop("no common IDs in PedIN and PedOUT")
  if (is.null(DumPrefix)) {
    SNPd <- intersect(Ped2$id, Ped1$id)
  } else {
    DPnc <- nchar(DumPrefix)
    SNPd <- Ped2$id[substr(Ped2$id,1,DPnc[1])!=DumPrefix[1] &
                      substr(Ped2$id,1,DPnc[2])!=DumPrefix[2]]
  }
  PedX <- merge(Ped1, Ped2[Ped2$id %in% SNPd, ], all.y=TRUE)
  DumPed <- Ped2[!Ped2$id %in% SNPd, ]
  Dummies <- list(DumPed$id[DumPed$id %in% Ped2$dam],
                  DumPed$id[DumPed$id %in% Ped2$sire])
  Par <- matrix(c("dam.1", "dam.2", "dam.r",
                  "sire.1", "sire.2", "sire.r"), 2,byrow=TRUE)

  #===  match dummies to non-genotyped parents  ===
  Sibs1 <- list()
  SibScore <- list()
  DumReal <- list()
  for (p in 1:2) {
    Sibs1[[p]] <- split(PedX$id, PedX[, Par[p,1]])
    Sibs1[[p]] <- Sibs1[[p]][!names(Sibs1[[p]]) %in% SNPd]
  }
  NoDummies <- with(PedX, all(dam.2 %in% SNPd | is.na(dam.2)) &
                      all(sire.2 %in% SNPd | is.na(sire.2)))
  if (!NoDummies) {
    for (p in 1:2) {
      Sibs2 <- split(PedX$id, PedX[, Par[p,2]])
      Sibs2 <- Sibs2[!names(Sibs2) %in% SNPd]

      if (length(Sibs1[[p]])>0) {
        SibScore[[p]] <- tdf(sapply(Sibs1[[p]], SibMatch, Sibs2, SNPd))  # slow!
        if (length(stats::na.exclude(SibScore[[p]][, "Best"])) >
            length(unique(stats::na.exclude(SibScore[[p]][, "Best"])))) {
          SibScore[[p]] <- SibScore[[p]][order(SibScore[[p]][, "OK"],
                                               decreasing=TRUE), ]
          dups <- duplicated(SibScore[[p]][, "Best"], incomparables=NA)
          BestS.d <- unique(SibScore[[p]]$Best[dups])
          if (sum(dups) > 1) {
            SibScore[[p]][dups, "Er"] <- rowSums(SibScore[[p]][dups, c("OK", "Er")])
          } else {
            SibScore[[p]][dups, "Er"] <- sum(SibScore[[p]][dups, c("OK", "Er")])
          }
          SibScore[[p]][dups, c("Best", "OK")] <- NA
          for (s in 1:length(BestS.d)) {
            tmp <- SibScore[[p]][which(SibScore[[p]]$Best==BestS.d[s]), ]
            if (tmp$OK==1 & tmp$Er>=1) {
              SibScore[[p]][which(SibScore[[p]]$Best==BestS.d[s]),
                            c("Best", "OK")] <- NA
            }
          }
        }
        tmp <- SibScore[[p]][!is.na(SibScore[[p]][, "Best"]), ]
        DumReal[[p]] <- as.data.frame(cbind(real = rownames(tmp),
                              dummy = tmp$Best), stringsAsFactors=FALSE)
        DumReal[[p]] <- merge(DumReal[[p]], DumPed[DumPed$id %in% Dummies[[p]],],
                              by.x="dummy", by.y="id", all=TRUE)[,c("real", "dummy")]
        DumReal[[p]][,"real"][is.na(DumReal[[p]][,"real"])] <- "nomatch"
      } else {
        SibScore[[p]] <- NA
        DumReal[[p]] <- data.frame(real=NA, dummy=NA)
      }
    }
    for (p in 1:2) {
      PedX <- merge(PedX, stats::setNames(DumReal[[p]], c(Par[p,3], Par[p,2])),
                    all.x=TRUE)
      DumPed <- merge(DumPed, DumReal[[p]], by.x="id", by.y="dummy", all.x=TRUE,
                      suffixes = c(".x",".y"))
    }
    DumPed$id.r <- apply(DumPed[,c("real.x", "real.y")], 1, function(x)
      ifelse(all(is.na(x)), NA, min(x, na.rm=T)))
    DumPed <- DumPed[, c("id", "dam.2", "sire.2", "id.r")]
    DumPed <- merge(DumPed, Ped1, all.x=TRUE, by.x="id.r", by.y="id",
                    suffixes=c(".2", ".1"))
    for (p in 1:2) {
      DumPed <- merge(DumPed, stats::setNames(DumReal[[p]], c(Par[p,3], Par[p,2])),
                      all.x=TRUE)
    }
  } else {
    PedX$dam.r <- NA
    PedX$sire.r <- NA
  }

  #===  Combined pedigree  ===
  PedX$id.r <- PedX$id
  PedY <- merge(PedX, DumPed, all=TRUE)  # NA's for id.r = "nomatch"
  PedY <- merge(PedY, stats::setNames(Ped1, c("id.r", "dam.1", "sire.1" )), all=TRUE)

  Founders <- list()
  NGpar <- list()
  for (p in 1:2) {
    Founders[[p]] <- unique(unlist(PedY[is.na(PedY[,Par[p,1]]) & is.na(PedY[,Par[p,2]]),
                                 c("id", "id.r")]))
    Sibs1[[p]] <- Sibs1[[p]][sapply(Sibs1[[p]],length)>1  |
                               !names(Sibs1[[p]]) %in% Founders[[p]]]
    NGpar[[p]] <- names(Sibs1[[p]])  # potential dummies
  }
  RD <- list(R = SNPd, D = c(unlist(NGpar), unlist(Dummies)) )

  Score <- array(0, dim=c(7, 5, 2),
                 dimnames=list(c("RR", "RD", "RT", "DR", "DD", "DT", "TT"),
            c("Total", "Match", "Mismatch", "P1only", "P2only"),
            c("f", "m")))
  ID <- c(R="id", D="id.r")
  for (p in 1:2) {
    for (i in c("R", "D")) {  # focal
      for (j in c("R", "D")) {  # parent
        if ((i=="D" | j=="D") & length(DumReal)==0) break
        ij <- paste0(i,j)
        k <- ifelse(j=="R", 2, 3)
        PedTmp <- PedY[which(PedY[,ID[i]] %in% RD[[i]] &
                          (PedY[,Par[p,1]] %in% RD[[j]] | PedY[,Par[p,2]] %in% RD[[j]])), ]
        Score[ij, "Total", p] <- nrow(PedTmp)
#        Score[ij, "MaxMatch", p] <- sum(!is.na(PedTmp[,Par[p,1]]) & PedTmp[,Par[p,1]]
#                                        %in% RD[[j]])
        Score[ij, "Match", p] <- sum(PedTmp[,Par[p,1]] == PedTmp[,Par[p,k]], na.rm=T)
        Score[ij, "P1only", p] <- sum(!is.na(PedTmp[,Par[p,1]]) & PedTmp[,Par[p,1]]
                                         %in% RD[[j]] & is.na(PedTmp[,Par[p,2]]))
        Score[ij, "P2only", p] <- sum(!is.na(PedTmp[,Par[p,2]]) & PedTmp[,Par[p,2]]
                                         %in% RD[[j]] & is.na(PedTmp[,Par[p,1]]))
        Score[ij, "Mismatch", p] <- sum(PedTmp[,Par[p,1]] != PedTmp[,Par[p,k]], na.rm=T)
      }
    }
  }
  for (p in 1:2) {  # Totals
    for (i in c("R", "D", "T")) {
      if (i=="D" & length(DumReal)==0) break
      ij <- paste0(i,"T")
      if (i != "T") {
        PedTmp <- PedY[which(PedY[,ID[i]] %in% RD[[i]] &
                            (!is.na(PedY[,Par[p,1]]) | !is.na(PedY[,Par[p,2]]))), ]
      } else {
        PedTmp <- PedY[!is.na(PedY[,Par[p,1]]) | !is.na(PedY[,Par[p,2]]), ]
      }
      Score[ij, "Total", p] <- nrow(PedTmp)
#      Score[ij, "MaxMatch", p] <- sum(!is.na(PedTmp[,Par[p,1]]))
      Score[ij, "P1only", p] <- sum(!is.na(PedTmp[,Par[p,1]]) & is.na(PedTmp[,Par[p,2]]))
      Score[ij, "P2only", p] <- sum(is.na(PedTmp[,Par[p,1]]) & !is.na(PedTmp[,Par[p,2]]))
      Score[ij, "Match", p] <- sum(PedTmp[,Par[p,1]] == PedTmp[,Par[p,2]] |
                                        PedTmp[,Par[p,1]] == PedTmp[,Par[p,3]], na.rm=T)
      Score[ij, "Mismatch", p] <- sum(PedTmp[,Par[p,1]] != PedTmp[,Par[p,2]] &
                  (PedTmp[,Par[p,1]] != PedTmp[,Par[p,3]] | is.na(PedTmp[,Par[p,3]])), na.rm=T)
    }
  }
  PedY <- PedY[, c("id", "dam.1", "sire.1", "dam.2", "sire.2",
                   "id.r", "dam.r", "sire.r")]

  PedY$dam.cat <- with(PedY, ifelse(is.na(dam.2) & !is.na(dam.1),
                                "O",
                                ifelse(id %in% SNPd,
                                  ifelse(dam.2 %in% SNPd,
                                     "P",
                                     ifelse(dam.2 %in% Dummies[[1]],
                                        ifelse(dam.r=="nomatch", "S", "SR"),
                                        NA)),
                                  ifelse(id %in% unlist(Dummies),
                                     ifelse(id.r == "nomatch",
                                        ifelse(dam.2 %in% SNPd,
                                           "G",
                                           ifelse(dam.r=="nomatch", "A", "AR")),
                                        ifelse(dam.2 %in% SNPd,
                                           "RG",
                                           ifelse(dam.r=="nomatch", "RA", "RAR"))),
                                     NA))))
  PedY$sire.cat <- with(PedY, ifelse(is.na(sire.2) & !is.na(sire.1),
                                "O",
                                ifelse(id %in% SNPd,
                                  ifelse(sire.2 %in% SNPd,
                                     "P",
                                     ifelse(sire.2 %in% Dummies[[2]],
                                        ifelse(sire.r=="nomatch", "S", "SR"),
                                        NA)),
                                      ifelse(id %in% unlist(Dummies),
                                         ifelse(id.r == "nomatch",
                                            ifelse(sire.2 %in% SNPd,
                                               "G",
                                               ifelse(sire.r=="nomatch", "A", "AR")),
                                            ifelse(sire.2 %in% SNPd,
                                               "RG",
                                               ifelse(sire.r=="nomatch", "RA", "RAR"))),
                                         NA))))
#   PedZ <- with(PedY[PedY$id %in% c(SNPd, unlist(Dummies)), ],
#                data.frame(id = ifelse(id.r!="nomatch", id.r, id),
#                           dam = ifelse(is.na(dam.r) | dam.r=="nomatch", dam.2, dam.r),
#                           sire = ifelse(is.na(sire.r) | sire.r=="nomatch", sire.2, sire.r),
#                           dam.cat = dam.cat,
#                           sire.cat = sire.cat,
#                           stringsAsFactors=FALSE))

  if(MergedPed) list(Score=Score, MergedPed=PedY) else Score
}


#============================================================================
#============================================================================
#' Find siblings

#' @param x  an ID
#' @param Ped  a pedigree with columns id - dam - sire
#'
#' @return The individuals which are full or half siblings to x, as a
#'   three-column matrix with column names id1 (x), id2 (the siblings), and
#'   RC (the relatedness category, 'FS' or 'HS').

rc <- function(x, Ped) {
  RelCat <- with(Ped,
                 ifelse(id == id[x], "S",
                        ifelse(eqv(dam[x],dam) & eqv(sire[x], sire), "FS",
                               ifelse(eqv(dam[x],dam) |  eqv(sire[x], sire), "HS",
                                      NA))))
  out <- cbind(id1 = Ped$id[x],
               id2 = Ped$id[!is.na(RelCat)],
               RC = stats::na.exclude(RelCat))
  out <- out[out[,"RC"] != "S", ]
  out
}


#============================================================================
#' Compare dyads
#'
#' Count the number of half and full sibling pairs correctly and incorrectly
#' assigned
#'
#' @param PedIN  True pedigree
#' @param PedOUT  Inferred pedigree
#'
#' @return A 3x3 table with the number of pairs assigned as full siblings (FS),
#'   half siblings (HS) or unrelated (U) in the two pedigrees.
#'
#' @export

DyadCompare <- function(PedIN, PedOUT) {

  PedT <- ReadTable(PedIN)[,1:3]
  names(PedT) <- c("id", "dam", "sire")
  PedI <- ReadTable(PedOUT, sep="")[,1:3]
  names(PedI) <- c("id", "dam", "sire")

  # note: each pair is counted double
  RCT <- matrix(NA, 0, 3)
  for (x in 1:nrow(PedT)) {
    RCT <- rbind(RCT, rc(x, PedT))
  }

  RCI <- matrix(NA, 0, 3)
  for (x in 1:nrow(PedI)) {
    RCI <- rbind(RCI, rc(x, PedI))
  }

  RCTI <- merge(as.data.frame(RCT, stringsAsFactors=FALSE),
                as.data.frame(RCI, stringsAsFactors=FALSE),
                by=c("id1", "id2"), all=TRUE, suffixes = c(".T", ".I"))
  RCTI <- RCTI[RCTI$id1 %in% PedT$id & RCTI$id2 %in% PedT$id &
                 RCTI$id1 %in% PedI$id & RCTI$id2 %in% PedI$id, ]
  RCTI$RC.T[is.na(RCTI$RC.T)] <- "U"
  RCTI$RC.I[is.na(RCTI$RC.I)] <- "U"
  RCTI$RC.T <- factor(RCTI$RC.T, levels=c("FS", "HS", "U"))
  RCTI$RC.I <- factor(RCTI$RC.I, levels=c("FS", "HS", "U"))

  tbl <- with(RCTI, Table(RC.T, RC.I))
  tbl["U", "U"] <- nrow(PedI) * (nrow(PedI)-1) - sum(tbl)
  tbl

  #  sweep(tbl, 1, rowSums(tbl), "/")
}


#============================================================================
#============================================================================
