# todo: check if sequoiaSpecs.txt exits & if param values OK prior to calling .Fortran

#' Pedigree Reconstruction
#'
#' Perform pedigree reconstruction based on SNP data, including parentage
#' assignment and sibship clustering.
#'
#' For each pair of candidate relatives, the likelihoods are calculated of them
#'  being parent-offspring, full siblings, half siblings, grandparent-
#'  grandoffspring, full avuncular (niece/nephew - aunt/uncle), half avuncular/
#'  great-grandparental/cousins, or unrelated. Assignments are made if the
#'  likelihood ratio (LLR) between the focal relationship and the most likely
#'  alternative exceed the threshold Tassign
#'
#' Detailed explanation of the various options and interpretation of the output
#'  is provided in the vignette.
#'
#' @param GenoFile character string with name of genotype file. Assumed to be in
#'   current working directory unless complete path is provided.
#' @param GenoFormat One of "raw", "ped", "col" or "seq". If "seq", genotype
#'  file should have an ID column and 1 column per SNP, coded as 0, 1, 2 or -9
#'   (missing), and no header row. For other formats, see \code{\link{GenoConvert}}.
#' @param LifeHistFile character string with name of life history data file,
#'  with 3 columns:
#'  \itemize{
#'  \item ID: max. 30 characters long,
#'  \item Sex: 1 = females, 2 = males, other numbers = unkown,
#'  \item BirthYear: Use negative numbers to denote missing values.}
#'  If the species has multiple generations per year, use an integer coding
#'   such that the candidate parents' `Birth year' is at least one larger than
#'   their putative offspring.
#' @param Prep TRUE: Save current parameter values to file, FALSE: use
#'    previous settings, as stored in `SequoiaSpecs.txt'.
#' @param CheckDup  Check the genotype and life history files for duplicate IDs
#'    and duplicated genotypes (neither is advised, but will not generate an
#'    error), and count how many individuals in the genotype file are not
#'    included in the life history file (permitted, but may hinder pedigree
#'     inference).
#' @param Parentage Run parentage analysis; assign genotyped parents to
#'   genotyped individuals.
#' @param AgePriors Calculate age-based prior probabilities for various
#'   categories of pairwise relatives, based on the age distribution of
#'   assigned parents (``par'', default once parents have been assigned),
#'   or use a default non-informative prior (``flat''), or use the ageprior
#'    from a previous run (``old''), stored as `AgePriors.txt' or provided in
#'     SeqList).
#' @param Sibships Perform sibship clustering, including assignment of
#'   grandparents to sibships and avuncular relationships between sibships.
#'   Note that this is by far the most time consuming step and may take several
#'   hours.
#' @param SeqList list with output from a previous partial run, see example.
#' @param Err Estimated genotyping error rate.
#' @param MaxMismatch Maximum number of loci at which candidate parent and
#'  offspring are allowed to be opposite homozygotes (integer).
#' @param Tfilter Threshold log-likelihood ratio between a proposed
#'   relationship versus unrelated, to select candidate relatives. Typically a
#'   negative value, related to the fact that unconditional likelihoods are
#'   calculated during the filtering steps. More negative values may decrease
#'   non-assignment, but will increase computational time.
#' @param Tassign Minimum log-likelihood ratio required for acceptance of
#'  proposed relationship, relative to next most likely relationship. Higher
#'  values result in more conservative assignments.
#' @param MaxSibshipSize  Maximum number of offspring for a single individual
#'  (a generous safety margin is advised).
#' @param NumSibRounds Number of iterations of sibship clustering. Sibship
#' clustering is iterated until convergence or until this maximum is reached.
#' @param Complexity  Either "full" (default), "simp" (simplified, no explicit
#'  consideration of inbred relationships) or "mono" (monogamous).
#' @param WriteFiles if TRUE, save all (intermediate) output to text files,
#'   if FALSE (default), return results as a list
#' @param Dir Directory to which output files will be written. If NULL
#'   (default) and WriteFiles=TRUE a subdirectory 'sequoiaOUT' in the current
#'    working directory is created, if NA use current working directory.
#' @param AgePriorFile Filename for ageprior (in & out, if applicable)
#' @param ParentageFile Filename for assigned parents
#' @param PedigreeFile Filename for pedigree after sibship clustering
#' @param quiet suppress messages
#'
#' @return A list with the following components when WriteFiles=FALSE, or
#'  otherwise a set of textfiles with the following names:
#' \tabular{lll}{
#' \strong{Name} \tab \strong{Generated by} \tab \strong{Description} \cr
#' AgePriors \tab Prep, \tab Age-based prior probabilities \cr
#' \tab AgePriors == "par" \tab \cr
#' DummyParents \tab Sibships \tab Half-sib clusters \cr
#' DuplicatesFound \tab CheckDup \tab duplicated genotypes and IDs \cr
#' NumberParents \tab Parentage \tab No. assigned parents \cr
#' ParentsAssigned \tab Parentage \tab Provisionary pedigree \cr
#' ParentsTotLik \tab Parentage \tab Total likelihood per iteration \cr
#' PedSeq \tab Sibships \tab Pedigree \cr
#' SequoiaSpecs \tab Prep \tab Parameter values \cr
#' SibTotLik \tab Sibships \tab Total likelihood per iteration \cr
#' UnassignedParents \tab Parentage \tab Non-assigned likely PO pairs \cr
#' UnassignedSibs \tab Sibships \tab Non-assigned likely relatives
#' }
#'
#' ParentsAssigned and PedSeq have the following columns:
#'   \item{id}{Individual ID}
#'   \item{dam}{Assigned mother, or NA}
#'   \item{sire}{Assigned father, or NA}
#'   \item{LLR_dam}{Log10-Likelihood Ratio (LLR) of this female being the mother,
#'      versus the next most likely relationship between the focal individual and
#'      this female (see Details for relationships considered)}
#'   \item{LLR_sire}{idem, for male parent}
#'   \item{LLR_pair}{LLR for the parental pair, versus the next most likely
#'     configuration (containing one or neither parent)}
#'   \item{OH_dam}{Number of loci at which the offspring and mother are
#'      opposite homozygotes}
#'   \item{OH_sire}{idem, for male parent}
#'
#' For details on the other elements, see the vignette.
#'
#' @author Jisca Huisman, \email{jisca.huisman@gmail.com}
#'
#' @references Huisman, J. Pedigree reconstruction from SNP data: Parentage
#'   assignment, sibship clustering, and beyond. (under review) Molecular
#'   Ecology Resources
#'
#' @seealso \code{\link{GenoConvert}, \link{PedCompare}}
#'
#' @examples
#' # Reconstruct a 2-generation pedigree;s See vignette for details.
#'
#' curdir <- getwd()
#' setwd(tempdir())
#' # copy files included in package (note: does not work without copying)
#' file.copy(system.file(file.path("extdata",c("SimGeno_example.txt",
#'    "LH_HSg5.txt")), package="sequoia"), tempdir())
#'
#' # save parameter values & do parentage assignment
#' SeqOUT <- sequoia(GenoFile = "SimGeno_example.txt",
#'                   LifeHistFile = "LH_HSg5.txt",
#'                   Prep=TRUE, Parentage=TRUE, Sibships = FALSE)
#' names(SeqOUT)
#' SeqOUT$NumberParents
#'
#' # do sibship clustering; slow (minutes to hours) for large datasets,
#' # but fast (seconds) for this example dataset with 214 individuals.
#' SeqOUT <- sequoia(Prep=FALSE, SeqList=SeqOUT, Parentage=FALSE,
#'                   Sibships=TRUE)
#' names(SeqOUT)
#' head(SeqOUT$PedSeq)  # pedigree with parents + dummy parents of sibships
#' file.remove("SimGeno_example.txt", "LH_HSg5.txt")
#' setwd(curdir)
#'
#' # Check for mismatches with input pedigree:
#' compare <- PedCompare(PedFile1=system.file(file.path("extdata","Ped_HSg5.txt"),
#'       package="sequoia"), Ped2=SeqOUT$PedSeq, MergedPed=TRUE)
#' compare$Score   # 2 mismatches, due to genotyping errors
#'
#' @export

sequoia <- function(GenoFile = NULL,
                    GenoFormat = "seq",
                    LifeHistFile = NULL,
                    Prep = TRUE,
                    CheckDup = TRUE,
                    Parentage = TRUE,
                    AgePriors = "par",
                    Sibships = TRUE,
                    SeqList = NULL,
                    Err = 0.0001,
                    MaxMismatch = 3,
                    Tfilter = -2.0,
                    Tassign = 0.5,
                    MaxSibshipSize = 100,
                    NumSibRounds = 5,
                    Complexity = "full",
                    WriteFiles = FALSE,
                    Dir = NULL,
                    AgePriorFile = "AgePriors.txt",
                    ParentageFile = "ParentsAssigned.txt",
                    PedigreeFile = "PedSeq.txt",
                    quiet = FALSE)
{
  MustBeBoolean <- list(Prep=Prep, CheckDup=CheckDup, Parentage=Parentage,
                     Sibships=Sibships, WriteFiles=WriteFiles, quiet=quiet)
  for (x in 1:length(MustBeBoolean)) {
    if (!is.logical(MustBeBoolean[[x]])) stop(paste(names(MustBeBoolean)[x], "must be TRUE/FALSE"))
  }
  if (!any(unlist(MustBeBoolean[1:5]))) message("Nothing to be done.")
  CurDir <- getwd()
  if (!is.null(GenoFile)) GenoFile <- normalizePath(GenoFile)
  if (!is.null(LifeHistFile)) LifeHistFile <- normalizePath(LifeHistFile)
  if (!WriteFiles) {
    Dir <- tempdir()
  } else {
    if (is.null(Dir)) Dir <- "sequoiaOUT"  # in current wd
    if (is.na(Dir)) Dir <- getwd()
  }
  Dir <- normalizePath(Dir)
  if(!dir.exists(Dir))  dir.create(Dir, recursive=TRUE)
  setwd(Dir)

  if (Prep & !is.null(SeqList)) warning("Settings in SeqList will be overruled when Prep=TRUE")
  if(!is.null(SeqList)) {  # write to tempdir / specified Dir
    for (x in 1:length(SeqList)) {
      if(names(SeqList)[x]=="SequoiaSpecs") {
        utils::write.table(as.data.frame(SeqList[[x]]), file="SequoiaSpecs.txt",
                           col.names = FALSE, sep = "\t,\t", quote = FALSE)
        Specs <- SeqList[[x]]
      } else {
        utils::write.table(SeqList[[x]], paste0(names(SeqList)[x],".txt"),
                           row.names = FALSE, sep = " ", quote = FALSE)
      }
    }
  }

  if (!Prep & !file.exists("SequoiaSpecs.txt")) {
    stop("Cannot find SequoiaSpecs.txt, please run with Prep=TRUE or provide SeqList")
  }
  if (!AgePriors %in% c("par","old","flat")) stop("Invalid value for AgePriors")
  if (WriteFiles & interactive() & !quiet) {
    ANS <- readline(prompt = paste("Results will be written to files in", Dir,
                                   "\n Note that this may overwrite existing files. \n",
                                   "Press <N> to abort, or any other key to continue."))
    if (substr(ANS, 1, 1) %in% c("N", "n")) stop()
  }
  if (Prep) {
    if (is.null(GenoFile)) {
      stop("Please provide name of GenoFile")
    }
    if (!file.exists(GenoFile)) stop("Cannot find GenoFile")
    if (is.null(LifeHistFile)) {
      warning("No lifehistory file provided")
    } else if (!file.exists(LifeHistFile)) {
      warning("Cannot find Lifehistory file")
    }
    if (!GenoFormat %in% c("raw","ped","col","seq")) stop("Invalid value for GenoFormat")
    if (!Complexity %in% c("full", "simp", "mono")) stop("Invalid value for Complexity")
    if (is.null(ParentageFile)) stop("Please provide name for Parentage file")
    if (is.null(AgePriorFile))  stop("Please provide name for Ageprior file")
    if (Err<0 | Err>1 | !is.double(Err)) stop("Invalid value for Err")
    if (MaxMismatch<0 | !is.wholenumber(MaxMismatch))  stop("Invalid value for MaxMismatch")
    if (!is.double(Tfilter))  stop("Invalid value for Tfilter")
    if (!is.double(Tassign))  stop("Invalid value for Tassign")
    if (MaxSibshipSize<0 | !is.wholenumber(MaxSibshipSize)) {
      stop("Invalid value for MaxSibshipSize")
    }
    if (NumSibRounds<0 | !is.wholenumber(NumSibRounds))  stop("Invalid value for MaxSibshipSize")

    numInd <- supprOF(SeqPrep(GenoFile, GenoFormat, LifeHistFile, Err,
                     MaxMismatch, Tfilter, Tassign,
                     MaxSibshipSize, NumSibRounds, Complexity,
                     AgePriorFile, ParentageFile, PedigreeFile),
            quiet)
    if (WriteFiles & !quiet) message("Specs written to SequoiaSpecs.txt")
    Specs <- data.frame(x=c(AgePriorFile, ParentageFile),
                        row.names=c("AgePriorFileName","ParentageFileName"),
                        stringsAsFactors=FALSE)
    if (AgePriors != "old") {
      supprOF(MakeAgeprior(UseParents = FALSE), quiet)
      if (WriteFiles & !quiet)  message(paste("Agepriors written to",
                                              Specs["AgePriorFileName", ]))
    }
  }

  if (AgePriors=="old" & !file.exists(Specs["AgePriorFileName",])) {
    stop(paste("Cannot find AgePrior file", Specs["AgePriorFileName",]))
  }

  if (CheckDup)  NumberDuplicates <- supprOF(SeqDup(), quiet)
  if (CheckDup & WriteFiles & !quiet) {
    if (sum(NumberDuplicates[,"n"])>0) {
      message("Duplicates & no-sex genotyped individuals written to DuplicatesFound.txt")
    }
  }
  ParList <- NULL
  SibList <- NULL
  if (Parentage) ParList <- supprOF(SeqParents(), quiet)
  if (Parentage & WriteFiles & !quiet) message("Assigned parents written to ",
                                               Specs["ParentageFileName",])

  if (AgePriors == "par" & (Parentage | Sibships)) {  # update agepriors
    if (file.exists(Specs["ParentageFileName",])) {
      supprOF(MakeAgeprior(UseParents = TRUE), quiet)
      if (WriteFiles & !quiet)  message(paste("Agepriors written to",
                                              Specs["AgePriorFileName", ]))
    } else {
      stop(paste("File", Specs["ParentageFileName",], "not found to update AgePriors.\n
           Use AgePriors = `flat` or run Parentage = TRUE first."))
    }
  }
  if (Sibships & !file.exists(Specs["ParentageFileName",])) {
    stop(paste("Cannot find file", Specs["ParentageFileName",],
               "\n Please run Parentage=TRUE first, even if data contains no candidate parents."))
  }
  if (Sibships) SibList <- supprOF(SeqSibs(), quiet)
  if (Sibships & WriteFiles & !quiet) message("Pedigree written to PedSeq.txt")

  if (!WriteFiles) {
    OutFiles <- intersect(list.files(),
                          c("AgePriors.txt", "DummyParents.txt", "DuplicatesFound.txt",
                            "NumberParents.txt", "ParentsAssigned.txt",
                            "ParentsTotLik.txt", "PedSeq.txt", "SequoiaSpecs.txt",
                            "SibTotLik.txt", "UnassignedParents.txt", "UnassignedSibs.txt"))
    OUT <- list()
    for (x in 1:length(OutFiles)) {
      if(OutFiles[[x]]=="SequoiaSpecs.txt") {
        OUT[[x]] <- ReadSpecs()
      } else {
        OUT[[x]] <- ReadTable(OutFiles[[x]], sep="", fill=TRUE)
      }
    }
    names(OUT) <- sapply(strsplit(OutFiles, split=".", fixed=TRUE),
                         function(x) x[1])
    unlink(c(OutFiles, "fort.6"))
  }
  setwd(CurDir)
  if (identical(Dir, normalizePath(tempdir()))) unlink(Dir)
  if(WriteFiles) return(c(ParList, SibList)) else return(c(OUT, ParList, SibList))
}
